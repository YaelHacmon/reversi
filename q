diff --git a/run/Board.cpp b/run/Board.cpp
deleted file mode 100644
index e38174f..0000000
--- a/run/Board.cpp
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#include <cstdlib>
-#include <stdexcept>
-#include "../include/Board.h"
-
-using namespace std;
-
-
-Board::Board(int size): size_(size) {
-	//allocate array of pointers of squares to represent board's first column (size_= #of rows)
-	// wrapped in try-catch block as expected
-	try {
-		gameBoard_ = new ElementInBoard*[size_];
-	} catch (...) {
-		cout << "Allocation of board failed: EXITING GAME" << endl;
-		exit(0);
-	}
-
-	//allocate all rows (size_= #of columns), and initialize matrix with empty squares
-	for (int i = 0 ; i<size_; i++) {
-		// allocate rows
-		// wrapped in try-catch block as expected
-		try {
-			gameBoard_[i] = new ElementInBoard[size_];
-		} catch (...) {
-			cout << "Allocation of board failed: EXITING GAME" << endl;
-			exit(0);
-		}
-
-		// initialize empty squares
-		for (int j = 0 ; j< size_; j++) {
-			//a cell will be empty by default
-			gameBoard_[i][j] = EMPTY;
-			//adding cell to list of empty cells
-			emptyCells_.push_back(Location(i, j));
-		}
-	}
-
-	//initialize board for the game - white is always at upper left corner of initialization square
-	//notice that c++ indexing requires to divide size in 2 then subtract 1 to reach the center of board
-	//initialize white squares
-	makeInColor(WHITE, Location(size_/2-1, size_/2-1));
-	makeInColor(WHITE, Location(size_/2, size_/2));
-	//initialize black squares
-	makeInColor(BLACK, Location(size_/2-1, size_/2));
-	makeInColor(BLACK, Location(size_/2, size_/2-1));
-}
-
-
-Board::~Board() {
-	//delete rows of matrix
-	for (int i = 0; i<size_; i++) {
-		delete gameBoard_[i];
-	}
-	//delete first column
-	delete gameBoard_;
-}
-
-Board::Board(const Board& other): size_(other.size())
-{
-	try {
-		gameBoard_ = new ElementInBoard*[size_];
-	} catch (...) {
-		cout << "Allocation of board failed: EXITING GAME" << endl;
-		exit(0);
-	}
-
-	for (int i = 0 ; i<size_; i++) {
-
-		// allocate rows
-		// wrapped in try-catch block as expected
-		try {
-			gameBoard_[i] = new ElementInBoard[size_];
-		} catch (...) {
-			cout << "Allocation of board failed: EXITING GAME" << endl;
-			exit(0);
-		}
-
-		// copy the other Board's cell value in the new board
-		for (int j = 0 ; j< size_; j++) {
-			gameBoard_[i][j] = other.gameBoard_[i][j];
-			emptyCells_ = other.emptyCells_;
-
-		}
-	}
-}
-
-Board::ElementInBoard**Board::getBoard()const
-{
-	return gameBoard_;
-}
-
-
-int Board::size() const {
-	return size_;
-}
-
-
-bool Board::isCellWhite(const Location& loc) const {
-	return getCell(loc)==WHITE;
-}
-
-
-bool Board::isCellBlack(const Location& loc) const {
-	return getCell(loc)==BLACK;
-}
-
-
-bool Board::isCellEmpty(const Location& loc) const {
-	return getCell(loc)==EMPTY;
-}
-
-
-bool Board::compareCellColors(const Location& loc1, const Location& loc2) const {
-	return getCell(loc1)==getCell(loc2);
-}
-
-bool Board::compareCellColors(const ElementInBoard& c, const Location& loc) const {
-	return getCell(loc)==c;
-}
-
-void Board::makeInColor(const ElementInBoard& c, const Location& loc) {
-	//if square is not empty - throw exception (cannot make a non-empty square in a color)
-	if (!isCellEmpty(loc)) {
-		throw logic_error("Logic problem: tried switching an empty square's color\n");
-	}
-
-	//else - change color of cell
-	gameBoard_[loc.row()][loc.column()] = c;
-	//remove from list of empty cells
-	emptyCells_.remove(loc);
-	//TODO  - could not use:
-	//removeCellFromEmptyList(loc);
-}
-
-
-void Board::flipColorInRange(const Location& prevStart, const Location& end, int rowJumps, int colJumps) {
-	//make sure both prevStart and end are in range of board
-	if (!isInBoardRange(prevStart) || !isInBoardRange(end)) {
-		return;
-	}
-
-	//avoid infinite loop in case of no jumps
-	if (rowJumps == 0 && colJumps == 0) {
-		return;
-	}
-
-	//iterate over board and change the location:
-	//initialize start of range
-	Location curr(prevStart);
-
-	//if end location cannot be reached by given jumps - there is no way to know when to stop
-	//check if row/column jumps are 0 before using the % operation (undefined for 0)
-	if (((rowJumps != 0) && ((end.row()-curr.row()) % rowJumps != 0)) ||
-			((colJumps) != 0 &&  ((end.column()-curr.column()) % colJumps != 0))) {
-		//return to avoid infinite loop
-		return;
-	}
-
-	//while location is still in given range - has not yet reached end
-	while (curr != end) {
-		//first move to next square (started with square previous to start)
-		curr.increment(rowJumps, colJumps);
-		//then flip next square
-		ElementInBoard e = getCell(curr);
-		if (e==WHITE) {
-			gameBoard_[curr.row()][curr.column()] = BLACK;
-		} else if (e==BLACK) {
-			gameBoard_[curr.row()][curr.column()] = WHITE;
-		} else {
-			throw logic_error("tried to flip an emty cell");
-		}
-	}
-}
-
-
-bool Board::isInBoardRange(const Location& loc) const {
-	//check that row and column values are between 0 and board size-1
-	return (loc.row() >= 0 && loc.column() >= 0 && loc.row() < size_ && loc.column() < size_);
-}
-
-
-bool Board::isEdge(const Location& loc) const {
-	return (loc.row()==0 || loc.row()==(size_-1) || loc.column()==0 || loc.column()==(size_-1));
-}
-
-
-bool Board::isBoardFull() const {
-	//if list is empty - board is full
-	return emptyCells_.empty();
-}
-
-
-std::list<Location>::const_iterator Board::emptyCellsBegin() const {
-	return emptyCells_.begin();
-}
-
-
-std::list<Location>::const_iterator Board::emptyCellsEnd() const {
-	return emptyCells_.end();
-}
-
-
-const Board::ElementInBoard& Board::getCell(const Location& loc) const {
-	return gameBoard_[loc.row()][loc.column()];
-}
-
-
-void Board::removeCellFromEmptyList(Location& removalPoint) {
-	emptyCells_.remove(removalPoint);
-}
diff --git a/run/Board.h b/run/Board.h
deleted file mode 100644
index 973a2d6..0000000
--- a/run/Board.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#ifndef BOARD_H_
-#define BOARD_H_
-
-#include "Location.h"
-#include <list>
-
-
-/**
- * Represents a Reversi game board.
- * By default board dimentions are 8*8, and game initialization is at center.
- *
- * It can show that matrix graphically and keeps track of the squares' locations.
- * It does not need to know a square's color and is not responsible for
- * maintaining changes in the square.
- * This allows for loose coupling and high cohesion.
- */
-class Board {
-
-
-	public:
-		/**
-		 * Enum for square/cell color, where black = 'X'. white = 'O'
-		 */
-		enum ElementInBoard {BLACK, WHITE, EMPTY};
-
-		/**
-		 * Default constructor, values are as demanded - 8*8
-		 *
-		 * @param size size of board
-		 */
-		Board(int size = 8);
-
-		/**
-		 * Destructor, since board size is decided during runtime.
-		 */
-		~Board();
-
-		/**
-		 * copy- constructor
-		 */
-		Board(const Board& other);
-
-		/**
-		 * Getter for size of board, which equals to number of columns and to number of rows
-		 * @return  size of board
-		 */
-		int size() const;
-
-
-		ElementInBoard** getBoard()const;
-
-		/**
-		 * Checks if the square in a given location is white.
-		 * @param loc square's location
-		 * @return true if square is white
-		 */
-		bool isCellWhite(const Location& loc) const;
-
-		/**
-		 * Checks if the square in a given location is black.
-		 * @param loc square's location
-		 * @return true if square is black
-		 */
-		bool isCellBlack(const Location& loc) const;
-
-		/**
-		 * Checks if the square in a given location is empty.
-		 * @param loc square's location
-		 * @return true if square is empty
-		 */
-		bool isCellEmpty(const Location& loc) const;
-
-		/**
-		 * Compares a the color of two given squares.
-		 * @param loc1 location of square 1
-		 * @param loc2 location of square 2
-		 * @return true if the square colors are identical, and not empty
-		 */
-		bool compareCellColors(const Location& loc1, const Location& loc2) const;
-
-		/**
-		 * Compares a the color of a given square to given color.
-		 * @param c color to compare square's color to
-		 * @param loc location of square
-		 * @return true if the colors are identical, and not empty
-		 */
-		bool compareCellColors(const ElementInBoard& c, const Location& loc) const;
-
-		/**
-		 * Turns an empty given location to given color.
-		 * @param c color to make empty square
-		 * @param loc location of square
-		 * @throw logic_error if cell is not empty - cannot change color of a non-empty square
-		 */
-		void makeInColor(const ElementInBoard& c, const Location& loc);
-
-		/**
-		 * Changes the color in a given range by given jumps from from black to white and vice versa. TODO -needed?
-		 *
-		 * @param prevStart square before start of range
-		 * @param end square of end of range
-		 * @param rowJumps jumps with which to iterate on rows
-		 * @param colJumps jumps with which to iterate on columns
-		 */
-		void flipColorInRange(const Location& prevStart, const Location& end, int rowJumps, int colJumps);
-
-		/**
-		 * Checks if a given loction is a part of board TODO -needed?
-		 * @param loc location to check
-		 * @return true if location is in range of board
-		 */
-		bool isInBoardRange(const Location& loc) const;
-
-
-		/**
-		 * Checks if location is at edge of board. TODO -needed?
-		 * @param loc loaction to check
-		 * @return true is location is an edge
-		 */
-		bool isEdge(const Location& loc) const;
-
-		/**
-		 * Checks if the board is full, by checking if there are no empty cells.
-		 * @return true if there are no empty cells
-		 */
-		bool isBoardFull() const;
-
-		/**
-		 * Gets begin() iterator for the list of empty cells.
-		 * @return iterator to the beginning of the empty cells list
-		 */
-		std::list<Location>::const_iterator emptyCellsBegin() const;
-
-		/**
-		 * Gets end() iterator for the list of empty cells.
-		 * @return iterator to the end of the empty cells list
-		 */
-		std::list<Location>::const_iterator emptyCellsEnd() const;
-
-	private:
-		//size of board, cannot be changed after initialization
-		const int size_;
-		//pointer to matrix of enums representing board, will by dynamically allocated during runtime
-		ElementInBoard** gameBoard_;
-		//list of locations of empty cells in board
-		std::list<Location> emptyCells_;
-
-		/**
-		 * Gets the square at a certain position on the board, for viewing only (square cannot be changed).
-		 * This is a wrapping function for clarity of code that ensures safety in terms of changing a square.
-		 *
-		 * @param loc square's location on board
-		 * @return wanted square
-		 */
-		const ElementInBoard& getCell(const Location& loc) const;
-
-		/**
-		 * Wrapping method for removing a location from the list of empty cells TODO-couldn't use - should remove?
-		 * @param removalPoint location for removal
-		 */
-		void removeCellFromEmptyList(Location& removalPoint);
-};
-
-#endif /* BOARD_H_ */
diff --git a/run/Board.o b/run/Board.o
deleted file mode 100644
index 9592747..0000000
Binary files a/run/Board.o and /dev/null differ
diff --git a/run/ComputerPlayer.cpp b/run/ComputerPlayer.cpp
deleted file mode 100644
index 8aa70a4..0000000
--- a/run/ComputerPlayer.cpp
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * Yael Hacmon, ID: 313297897
- * ComputerPlayer.cpp
- */
-#include <iostream>
-#include <limits>
-#include "../include/MoveLogic.h"
-#include "../include/ComputerPlayer.h"
-#include <vector>
-
-using namespace std;
-
-//according to minimax algorithm
-Location ComputerPlayer::getNextMove(const ViewGame* view, const MoveLogic* logic, const Board& board, const Player* other)
-{
-	//initialize minimax value to maximum value possible
-	int minimax = std::numeric_limits<int>::max();
-
-	//initialize best move to first possible move - will make sure move returned is legal at any case
-	Location bestMove(this->getPossibleMoves()[0]);
-
-	//TODO - not sure this is needed, and quite sure it presents a logical problem:
-	//consider a situation where other player has no
-	//moves, but making a move will create moving options for opponent
-	/*if(!other->hasPossibleMoves()){
-		return  possiblCurrenteMoves[0];
-	}*/
-
-	//execute algorithm
-	//for each of the computer player possible move - check what is the highest possible score for opponent
-	for(vector<Location>::const_iterator compMove = this->getPossibleMoves().begin();
-			compMove != this->getPossibleMoves().end(); ++compMove){
-
-		//std::cout << "loop1 for " << *compMove << "\n";
-		//copy all participating objects - to work on copies (leave originals untouched)
-		Board copyBoard(board);
-		Player* copyOther = other->clone();  //using clones for abstract types (no copy c'tor possible)
-		Player* copyThis = this->clone();
-
-		/*TODO - vectors are cloned as empty (using size)!!
-		 * and yet - loop 2 is entered for the moves (5,6) (6,5) (6,6) in every iteration, because of updateMoveOptions() called
-		 * right before loop (moves found are the same - because board has not changed because playGame() did not play).
-		 */
-
-		//play move for the current player
-		logic-> playMove(*compMove, copyThis, copyBoard, copyOther);
-
-		//update the possible moves for the opponent player
-		logic-> updateMoveOptions(copyOther, copyBoard);
-
-		//initialize maximal seen score of a player's move to smallest number possible
-		int maxScore = numeric_limits<int>::min();
-
-		//for each of the possible moves of the other player - check what is the possible score of move
-		for(vector<Location>::const_iterator oppMove = copyOther->getPossibleMoves().begin();
-				oppMove != copyOther->getPossibleMoves().end(); ++oppMove){
-			std::cout << "\tloop2 for " << *oppMove << "\n";
-
-			//copy all participating objects - to work on copies (leave originals copies as changed in first loop)
-			Board secondCopyBoard(copyBoard);
-			Player* secondCopyOther = copyOther->clone();
-			Player* secondCopyThis = copyThis->clone();
-
-			//play the possible move for opponent, current player is now the "other player"
-			logic-> playMove(*oppMove, secondCopyOther, secondCopyBoard, secondCopyThis);
-
-			//get change in scores (opponent's score minus computer's score)
-			int diff = secondCopyOther->getScore() - secondCopyThis->getScore();
-
-			//if we found a new best move for opponent - save score
-			if (diff > maxScore)
-				maxScore = diff;
-
-		}
-
-		//if best move opponent can play is worse then found best move for opponent -
-		//current move is our best choice - save it
-		if(maxScore < minimax){
-			minimax = maxScore;
-			bestMove = *compMove;
-		}
-	}
-
-	//return best move
-	return bestMove;
-}
-
-
-Player* ComputerPlayer::clone() const
-{
-	return new ComputerPlayer(*this);
-}
diff --git a/run/ComputerPlayer.h b/run/ComputerPlayer.h
deleted file mode 100644
index 5bcbd4b..0000000
--- a/run/ComputerPlayer.h
+++ /dev/null
@@ -1,45 +0,0 @@
-
-#ifndef ComputerPlayer_H_
-#define ComputerPlayer_H_
-
-#include "Player.h"
-
-/**
- * Represents a computer player in a game.
- */
-class ComputerPlayer: public Player
-{
-public:
-	/**
-	 * Constructor of ComputerPlayer. Name and color must be given.
-	 *
-	 * @param name player's name
-	 * @param c player's color
-	 */
-	ComputerPlayer(const std::string& name, const Player::ColorOfPlayer& c): Player(name, c){};
-
-	/**
-	 * Copy c'tor. Calls base's copy c'tor and updates possible moves
-	 * @param player to copy
-	 */
-	ComputerPlayer(const Player& other): Player(other) {updatePossibleMoves(other.getPossibleMoves());};
-
-	/**
-	 * Returns player's next move in game by minimax algorithem
-	 *
-	 * @param v view to interact with player - accept input and make sure input is valid
-	 * @param logic rules of current game
-	 * @param b board on which game is being played
-	 * @param current current player
-	 * @param other opponent player
-	 *
-	 * @return location of next player's move
-	 */
-	Location getNextMove(const ViewGame* view, const MoveLogic* logic, const Board& board, const Player* other);
-
-	Player* clone() const;
-};
-
-
-
-#endif /* ComputerPlayer_H_ */
diff --git a/run/ComputerPlayer.o b/run/ComputerPlayer.o
deleted file mode 100644
index 6121f63..0000000
Binary files a/run/ComputerPlayer.o and /dev/null differ
diff --git a/run/GameManager.cpp b/run/GameManager.cpp
deleted file mode 100644
index 0f11747..0000000
--- a/run/GameManager.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * GameManager.cpp
- */
-
-#include "../include/GameManager.h"
-
-using namespace std;
-
-GameManager::GameManager(ViewGame* view, Board& b, Player* black, Player* white, MoveLogic* log):
-														board_(b), currPlayer_(black), oppPlayer_(white), logic_(log), view_(view) {}
-
-
-void GameManager::playGame() {
-	//declare flag - in first turn game has not been played, current player has moves
-	bool noMoves = false;
-
-	view_->showMessage("Current board:");
-	view_->printBoard(board_.getBoard(), board_.size());
-
-	/* General explanation - First, build a list containing all the
-	 * empty cells on the board. then, checking what might be a possible
-	 * move to the player, and putting all the options into a vector.
-	 * The user select a point, and the board update acoording to the
-	 *  selected point.
-	 */
-
-	//while game is not over - keep playing
-	while (!board_.isBoardFull())
-	{
-		//display current turn
-		view_->messageForTurn(currPlayer_->getName());
-
-		//initialize moves for black and white players
-		logic_->updateMoveOptions(currPlayer_, board_);
-
-		//declare move here - so we can show move later
-		Location move(-1,-1);
-
-		//if current player can play his turn
-		if (logic_->canPlayTurn(currPlayer_)) {
-			//show possible moves
-			view_->messagePossibleMoves(currPlayer_->getPossibleMoves());
-
-			//get next player's move
-			move = currPlayer_->getNextMove(view_, logic_, board_,oppPlayer_);
-
-			//check that move is allowed
-			//while move isn't legal - get another move from player
-			while (!logic_->isMoveAllowed(move, currPlayer_))
-			{
-				view_->showMessage("Illegal move, try again.");
-				move = currPlayer_->getNextMove(view_, logic_, board_,oppPlayer_);
-			}
-
-			//call logic to play move
-			logic_->playMove(move, currPlayer_, board_, oppPlayer_);
-
-			//update flag
-			noMoves = false;
-		}
-		//if current player cannot play his turn
-		else
-		{
-			//if the second player cannot play - show message and switch turns
-			if (!noMoves) {
-				view_->messageSwitchTurns();
-				noMoves = true;
-
-			}
-			else
-			{
-				//if both players did not play - game is over, there are no more moves left in game
-				view_->showMessage("No possible moves for both players.");
-				break;
-			}
-		}
-
-		//show board and last moves
-		view_->showMessage("Current board:");
-		view_->printBoard(board_.getBoard(), board_.size());
-		//message of last turn - if was played
-		if (!noMoves) {
-			view_->messagePlayerMove(move, currPlayer_->getName());
-		}
-
-		//switch players
-		Player* temp = currPlayer_;
-		currPlayer_ = oppPlayer_;
-		oppPlayer_ = temp;
-	}
-	showWinner();
-}
-
-
-void GameManager::showWinner()
-{
-	if (currPlayer_->getScore() > oppPlayer_->getScore()) {
-		view_->messageWinner(currPlayer_->getName());
-	}
-	else if (currPlayer_->getScore() < oppPlayer_->getScore())
-	{
-		view_->messageWinner(oppPlayer_->getName());
-	}
-	else
-	{
-		view_->showMessage("Tie!! Players have equal scores.");
-	}
-}
diff --git a/run/GameManager.h b/run/GameManager.h
deleted file mode 100644
index 7d67f27..0000000
--- a/run/GameManager.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * GameManager.h
- */
-
-#ifndef GameManager_H_
-#define GameManager_H_
-
-#include <iostream>
-#include "Board.h"
-#include "MoveLogic.h"
-#include "Player.h"
-#include "Location.h"
-#include "ViewByConsole.h"
-#include "HumanPlayer.h"
-
-/**
- * Controls the game flow of a Reversi game when given a board, two players
- * and an object to control the logic of every move.
- *
- * Is responsible for playing the turns, knowing and notifying when the game ends, and printing
- * messages to the players.
- */
-class GameManager {
-public:
-	/**
-	 * Constructor taking a board on which to play game, two players, and the logic of the moves.
-	 * @param b board of game
-	 * @param black black player
-	 * @param white white player
-	 * @param log logic to handle moves
-	 */
-	GameManager(ViewGame* view, Board& b, Player* black, Player* white, MoveLogic* log);
-
-	/**
-	 * Plays game with the given board, players and logic.
-	 */
-	void playGame();
-
-private:
-	//board of game
-	Board board_;
-
-	//current player - by reference, to allow polymorphism. Starting player is black by default.
-	Player* currPlayer_;
-
-	//white player - by reference, to allow polymorphism. Opposite player is black by default.
-	Player* oppPlayer_;
-
-	//handles logic of moves - by reference, to allow polymorphism
-	MoveLogic* logic_;
-
-	//way to view game
-	ViewGame* view_;
-
-	/**
-	 * Returns winner of game.
-	 * @return player who won this game
-	 */
-	void showWinner();
-};
-
-
-#endif /* GameManager_H_ */
diff --git a/run/GameManager.o b/run/GameManager.o
deleted file mode 100644
index ba2a41b..0000000
Binary files a/run/GameManager.o and /dev/null differ
diff --git a/run/HumanPlayer.cpp b/run/HumanPlayer.cpp
deleted file mode 100644
index 1a8d34b..0000000
--- a/run/HumanPlayer.cpp
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * Yael Hacmon, ID: 313297897
- * HumanPlayer.cpp
- */
-
-
-#include <iostream>
-#include <limits>
-#include "../include/MoveLogic.h"
-#include "../include/HumanPlayer.h"
-
-using namespace std;
-
-Location HumanPlayer::getNextMove(const ViewGame* view, const MoveLogic* logic, const Board& board, const Player* other)
-{
-	//ask for move
-	view->showMessage("Please enter your moves row,col:");
-
-	//return choice of move
-	return view->getMoveFromUser();
-}
-
-Player* HumanPlayer::clone() const
-{
-	return new HumanPlayer(*this);
-}
diff --git a/run/HumanPlayer.h b/run/HumanPlayer.h
deleted file mode 100644
index 0674597..0000000
--- a/run/HumanPlayer.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * HumanPlayer.h
- */
-
-#ifndef HumanPlayer_H_
-#define HumanPlayer_H_
-
-#include "Player.h"
-
-
-/**
- * Represents a human player in a game played via the console.
- */
-class HumanPlayer: public Player {
-public:
-	/**
-	 * Constructor of HumanPlayer. Name and color must be given.
-	 *
-	 * @param name player's name
-	 * @param c player's color
-	 */
-	HumanPlayer(const std::string& name, const Player::ColorOfPlayer& c): Player(name, c){};
-
-	/**
-	 * Copy c'tor. Calls base's copy c'tor and updates possible moves
-	 * @param player to copy
-	 */
-	HumanPlayer(const Player& other): Player(other) {updatePossibleMoves(other.getPossibleMoves());};
-
-	/**
-	 * implement clone function for making copy of Player object
-	 * of any type. use clone because Player have derived classes.
-	 */
-	virtual Player* clone() const;
-
-	/**
-	 * Returns human player's next move in game, by asking user to enter their choice.
-	 *
-	 * @param v view to interact with player - accept input and make sure input is valid
-	 * @param logic rules of current game
-	 * @param b board on which game is being played
-	 * @param other opponent
-	 * @return location of next player's move
-	 */
-	virtual Location getNextMove(const ViewGame* view, const MoveLogic* logic, const Board& board, const Player* other);
-};
-
-
-#endif /* HumanPlayer_H_ */
diff --git a/run/HumanPlayer.o b/run/HumanPlayer.o
deleted file mode 100644
index eb04a01..0000000
Binary files a/run/HumanPlayer.o and /dev/null differ
diff --git a/run/Location.cpp b/run/Location.cpp
deleted file mode 100644
index ab6dd26..0000000
--- a/run/Location.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * Location.cpp
- */
-
-#include "../include/Location.h"
-
-using namespace std;
-
-Location::Location (int row, int col): row_(row), col_(col) {}
-
-void Location::set(int row, int col) {
-	row_ = row;
-	col_ = col;
-}
-
-void Location::set(Location& loc) {
-	set(loc.row(), loc.column());
-}
-
-void Location::increment(int incR, int incC) {
-	row_ += incR;
-	col_ += incC;
-}
-
-int Location::column() const {
-	return col_;
-}
-
-int Location::row() const {
-	return row_;
-}
-
-bool Location::operator ==(const Location &loc) const {
-	//compare rows and columns
-	return (loc.row() == row_ && loc.column() == col_);
-}
-
-bool Location::operator !=(const Location &loc) const {
-	//use == operator for
-	return !(*this==loc);
-}
-
-ostream &operator <<(ostream &out, const Location &loc)
-{
-	//translate from c++ indexing
-	out << "(" << loc.row_+1 << "," << loc.col_+1 << ")";
-	return out;
-}
-
diff --git a/run/Location.h b/run/Location.h
deleted file mode 100644
index 77736c0..0000000
--- a/run/Location.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * Location.h
- */
-
-#ifndef LOCATION_H_
-#define LOCATION_H_
-
-#include <iostream>
-
-/**
- * A location contains a row and a column of a square in the Board matrix.
- * Represents a point in a 2D space.
- */
-class Location {
-	public:
-		/**
-		 * C'tor of location.
-		 * @param row row
-		 * @param col column
-		 */
-		Location (int row, int col);
-
-		/**
-		 * Sets new row and column to location.
-		 * @param row new row
-		 * @param col new column
-		 */
-		void set(int row, int col);
-
-		/**
-		 * Sets new row and column to location
-		 * @param loc location who's data to copy
-		 */
-		void set(Location& loc);
-
-		/**
-		 * Increments location's row and column by given numbers.
-		 * @param incR how much to increment rows by
-		 * @param incC how much to increment columns by
-		 */
-		void increment(int incR, int incC);
-
-		/**
-		 * Getter.
-		 * @return column of location
-		 */
-		int column() const;
-
-		/**
-		 * Getter.
-		 * @return row of location
-		 */
-		int row() const;
-
-		/**
-		 * Overloading of == operator for easy comparison
-		 * @param loc other location to compare to
-		 * @return true if both row and column of locations match
-		 */
-		bool operator ==(const Location &loc) const;
-
-		/**
-		 * Overloading of != operator for easy comparison
-		 * @param loc other location to compare to
-		 * @return true if either row or column of locations do not match
-		 */
-		bool operator !=(const Location &loc) const;
-
-		/**
-		 * Overloading of << for easy printing, using friend function.
-		 * @param out output stream
-		 * @param loc location to print
-		 * @return output stream with printed location
-		 */
-		friend std::ostream &operator <<(std::ostream &out, const Location &loc);
-
-	private:
-		int row_;
-		int col_;
-};
-
-
-#endif /* LOCATION_H_ */
diff --git a/run/Location.o b/run/Location.o
deleted file mode 100644
index 2c5a69c..0000000
Binary files a/run/Location.o and /dev/null differ
diff --git a/run/Menu.cpp b/run/Menu.cpp
deleted file mode 100644
index b154d80..0000000
--- a/run/Menu.cpp
+++ /dev/null
@@ -1,39 +0,0 @@
-
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#include "../include/Menu.h"
-#include "../include/HumanPlayer.h"
-#include "../include/ComputerPlayer.h"
-
-using namespace std;
-
-Menu::Menu() {
-	//initialize messages to user as strings in the player options string vector
-	playerOptions_.push_back("Choose white player's type:"); //index 0
-	playerOptions_.push_back("play against a human player"); //index 1
-	playerOptions_.push_back("play against an AI player"); //index 2
-}
-
-
-Player* Menu::getPlayerByUserChoice(ViewGame& view) {
-	//call view to show menu and return player's option
-	//TODO - not actually a nice way to do this... maybe we should split into "show" and "get choice" - one action per method
-	int choice = view.presentMenu(playerOptions_);
-
-	//create and return a player type according to user's choice TODO - should return by reference or as pointer?
-	switch(choice) {
-		case 1:
-			return new HumanPlayer("O", Board::WHITE);
-
-		case 2:
-			return new ComputerPlayer("O", Board::WHITE);
-
-		default:
-			view.showMessage("Problem creating players");
-			break;
-	}
-	return new HumanPlayer("O",  Board::WHITE);
-}
diff --git a/run/Menu.h b/run/Menu.h
deleted file mode 100644
index 9e25e5f..0000000
--- a/run/Menu.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#ifndef MENU_H_
-#define MENU_H_
-
-#include "ViewGame.h"
-#include "Player.h"
-#include <vector>
-
-/**
- * Holds the options for different settings of the game, and knows to return the game's parameters accordingly.
- * Allows use of the Factory design pattern for runtime creation of object types by the user's choice (Menu is the factory class).
- */
-class Menu {
-	public:
-		/**
-		 * Constructor, no parameters.
-		 * Will initialize the options string array with messages for every index
-		 */
-		Menu();
-
-		/**
-		 * Returns a type of player to play in game, by the player's choice
-		 * Uses the view to show the menu, then accepts a player's decision and acts upon it.
-		 *
-		 * @param view to show menu options with
-		 * @return a type of Player
-		 */
-		Player* getPlayerByUserChoice(ViewGame& view);
-
-	private:
-		//vector to hold messages of options at index of choice. Using a vector for easy access to length along with easy iteration.
-		std::vector<std::string> playerOptions_;
-};
-
-
-
-#endif /* MENU_H_ */
diff --git a/run/Menu.o b/run/Menu.o
deleted file mode 100644
index c01d947..0000000
Binary files a/run/Menu.o and /dev/null differ
diff --git a/run/MoveLogic.cpp b/run/MoveLogic.cpp
deleted file mode 100644
index e523d37..0000000
--- a/run/MoveLogic.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * MoveLogic.cpp
- */
-
-#include "../include/MoveLogic.h"
-#include <vector>
-
-
-//empty implementation of c'tor
-MoveLogic::MoveLogic() {}
-
-//empty implementation of virtual destructor
-MoveLogic::~MoveLogic() {}
-
-
-bool MoveLogic::canPlayTurn(const Player* player) const {
-	//check if player can play moves
-	return player->hasPossibleMoves();
-}
-
-
-bool MoveLogic::isMoveAllowed(const Location& move, const Player* player) const {
-	//copy vector by reference to avoid recalling getter function
-	vector<Location> possibleMoves = player->getPossibleMoves();
-
-	//go over vector
-	for (int i = 0; i< possibleMoves.size(); i++) {
-		//if move's location is equal to a possible move's location - it is allowed
-		if (possibleMoves[i]==move) {
-			return true;
-		}
-	}
-	//otherwise, given move is not a possible move for player - and therefor is not allowed
-	return false;
-}
-
-
-void MoveLogic::updateMoveOptions(Player* player, const Board& board) const {
-	//get board size and initialize variables
-	int size = board.size();
-	std::vector<Location> final;
-	Board::ElementInBoard color = player->getColor();
-
-	//go over board, for each square check if it can be a move. if so - add to vector.
-	for(list<Location>::const_iterator iter = board.emptyCellsBegin();
-			iter != board.emptyCellsEnd(); ++iter) {
-		//use pure virtual method to decide if a move is possible by decided logic (template pattern)
-		if (isPossibleMoveByLogic(color, *iter, board))
-		{
-			final.push_back(*iter);
-		}
-	}
-
-	//update player's list of possible move locations (copies vector using copy c'tor - no error when leaving method)
-	player->updatePossibleMoves(final);
-}
-
-
-Location MoveLogic::lastInColorRange(const Player::ColorOfPlayer pColor, const Location& prevStart,
-		const Location& end, const Board& board) const {
-	/* TARGET: Location of the first square in the given board that matches the given color (not including prevStart).
-	 * If none are found - the location of prevStart.
-	 * Implementation traverses board by given range, while the location is still in color range.
-	 * Requirements for staying in color range:
-	 * 1. Location is still in range of board.
-	 * 2. Location has the opposite color to given prevStart square. */
-
-	//make sure both prevStart and end are in range of board - if not return prevStart
-	if (!board.isInBoardRange(prevStart) || !board.isInBoardRange(end)) {
-		return prevStart;
-	}
-
-	//find jumps in rows'/columns' numbers using given edge
-	int rowJumps = jumps(prevStart.row(), end.row());
-	int colJumps = jumps(prevStart.column(), end.column());
-
-	//avoid infinite loop in case both jumps equal zero
-	if (rowJumps == 0 && colJumps == 0) {
-		return prevStart;
-	}
-
-	//initialize current location to start
-	Location curr(prevStart);
-	curr.increment(rowJumps, colJumps);
-
-	//while current location is still in board range, is not empty, and has the opposite color than prevStart
-	while (board.isInBoardRange(curr) && (!board.isCellEmpty(curr) && !board.compareCellColors(pColor, curr))) {
-		curr.increment(rowJumps, colJumps);
-	}
-
-	//if the last square is out of board range, or empty - there is no square matching given color
-	if (!board.isInBoardRange(curr) || board.isCellEmpty(curr)) {
-		//return prevStart as required
-		return prevStart;
-	}
-
-	//return the location before the last - no matter why while loop was broken, the current
-	//location is not the wanted one: either not same color or not in range.
-	curr.increment(-rowJumps, -colJumps);
-	return curr;
-}
-
-
-int MoveLogic::jumps(const int start, const int someNext) const {
-	//get difference in rows
-	int diff = someNext - start;
-
-	//if difference is positive, then some next is greater than start
-	if (diff > 0) {
-		//range direction is to the right/bottom
-		return 1;
-	}
-
-	//if difference is negative, then start is greater than some next
-	if (diff < 0) {
-		//range direction is to the left/top
-		return -1;
-	}
-
-	//else - difference is zero - no change in row/column numbers
-	return 0;
-}
diff --git a/run/MoveLogic.h b/run/MoveLogic.h
deleted file mode 100644
index c5a3f70..0000000
--- a/run/MoveLogic.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * MoveLogic.h
- */
-
-#ifndef MOVELOGIC_H_
-#define MOVELOGIC_H_
-
-#include "Board.h"
-#include "Player.h"
-#include "Location.h"
-
-/**
- * This class is in charge of maintaining, checking and enforcing a game's rules for a move.
- * It makes sure that every move follows the game's chosen logic.
- * Abstract class, seeing as there can be different sets of rules for this game, with different logic.
- *
- * It does not contain any private members, and therefore can be used for handling more than one game.
- * This allows for loose coupling in the design.
- */
-class MoveLogic {
-	public:
-		/**
-		 * Constructor. Seeing as class has no members - c'tor has no parameters.
-		 */
-		MoveLogic();
-
-		/**
-		 * Virtual destructor.
-		 */
-		virtual ~MoveLogic();
-
-		/**
-		 * Plays the given move for the given player on given board, according to the logic decided.
-		 * Changes must be made to board, so it cannot be constant.
-		 * The rules for playing a move differ in each set of rules, and therefore this method is a
-		 * pure virtual method, to be implemented in derived classes.
-		 *
-		 * @param move location of chosen move
-		 * @param player pointer to player playing move
-		 * @param opponent pointer to other player of game
-		 * @param board pointer to board on which move is played
-		 */
-		virtual void playMove(const Location& move, Player* player, Board& board, Player* opponent) const = 0;
-
-		/**
-		 * Checks if given player can currently play a turn.
-		 * A player can play if the list of player's next possible moves is not empty.
-		 * Even so, a derived class may need a completely different implementation, and therefore it is still virtual.
-		 *
-		 * @param player pointer to player
-		 * @return true if player can currently play a turn
-		 */
-		virtual bool canPlayTurn(const Player* player) const;
-
-		/**
-		 * Returns if a given move by a given player on given board is allowed.
-		 * A move is allowed if it is a possible move, meaning it is contained
-		 * in the player's possible moves vector.
-		 *
-		 * @param move location of move to check if legal
-		 * @param player pointer to player playing this move
-		 * @return true if move is legal and can be played
-		 */
-		virtual bool isMoveAllowed(const Location& move, const Player* player) const;
-
-		/**
-		 * Updates the list of possible moves for the given player on the given board.
-		 * 	Change must be made to actual player, so it is not constant.
-		 * Depends on the set of rules chosen for the game, and therefore uses a template pattern in the implementation,
-		 * using possibleMoveDirections pure virtual method.
-		 * Even so, a derived class may need a completely different implementation, and therefore it is still virtual.
-		 *
-		 * @param player pointer to player of which to update moves
-		 * @param board pointer to board on which game is played
-		 */
-		virtual void updateMoveOptions(Player* player, const Board& board) const;
-
-	protected:
-		/**
-		 * Checks if a given location can be a possible move by this logic's rules.
-		 * Is pure virual because depends on the specific implemetation of MoveLogic.
-		 *
-		 * @param color to make given cell location
-		 * @param location of cell
-		 * @param board pointer to board on which move is to be played
-		 */
-		virtual bool isPossibleMoveByLogic(const Player::ColorOfPlayer color, const Location& location,
-				const Board& board) const = 0;
-
-
-		/**
-		 * Checks if given move is an option for given player to make on the given board in all 8 directions,
-		 * and if so - saves location of last square in opposite-colored range to the passed Locations array.
-		 * Depends on the set of rules applied, so must be implemented only in derived classes.
-		 *
-		 * @param dirs array of 8 locations, initialized to checked move option location
-		 * @param pColor color of player making the move
-		 * @param board pointer to board on which move is to be played
-		 */
-		virtual void possibleMoveDirections(Location* dirs, const Player::ColorOfPlayer pColor, const Board& board) const = 0;
-
-		/**
-		 * Returns the location of the last square in a range of consecutive same-colored squares.
-		 *
-		 * Method looks for the first square in the given board that does not match the color of the given start location,
-		 * up to the given end location. If such a square is found before reaching the end - it's location is returned.
-		 * Otherwise, the last found square's location is returned.
-		 * The squares are checked in the specified differences, which allowes for traversing rows, columns and
-		 * diagonals in all directions.
-		 *
-		 * @param prevStart location of square before start of inquiry range
-		 * @param end  edge of board - end of inquiry range
-		 * @param board  pointer to board in which we are searching for the range
-		 * @param pColor color of played move - color to be in given prevStart location
-		 * @return location of the next first square in the given board and range that matches the prevStart
-		 * 				 square's color, or if none are found - the location of prevStart.
-		 */
-		Location lastInColorRange(const Player::ColorOfPlayer pColor, const Location& prevStart,
-				const Location& end, const Board& board) const;
-
-
-		/**
-		 * Determines the jump differences in a range of rows/columns for current iteration over board.
-		 * In the Reversi game, we examine a the board one square at a time (jumps of 1). Therefore some location down
-		 * the wanted iterating range is enough to determine the direction of this iteration, and return the jump difference.
-		 *
-		 * Even so, a derived logic class may decide to act differently, so method is declared virtual.
-		 *
-		 * @param start start of iteration range
-		 * @param next some location down the iteration range
-		 * @return -1, 0, or 1: difference in rows/columns in this iteration
-		 */
-		virtual int jumps(const int start, const int someNext) const;
-};
-
-
-#endif /* MOVELOGIC_H_ */
diff --git a/run/MoveLogic.o b/run/MoveLogic.o
deleted file mode 100644
index 54d0d25..0000000
Binary files a/run/MoveLogic.o and /dev/null differ
diff --git a/run/Player.cpp b/run/Player.cpp
deleted file mode 100644
index 048d9e4..0000000
--- a/run/Player.cpp
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#include "../include/Player.h"
-
-Player::Player(const std::string& name, const ColorOfPlayer& c): name_(name), color_(c), score_(2){
-	possibleMoves_ = std::vector<Location>();
-}
-
-Player::Player(const Player& other): name_(other.getName()), color_(other.getColor()), score_(other.getScore()) {};
-
-//empty destructor
-Player::~Player() {}
-
-Player::ColorOfPlayer Player::getColor() const {
-	return color_;
-}
-
-
-const std::string& Player::getName() const {
-	return name_;
-}
-
-
-int Player::getScore() const {
-	return score_;
-}
-
-
-const std::vector<Location>& Player::getPossibleMoves() const {
-	return possibleMoves_;
-}
-
-
-bool Player::hasPossibleMoves() const {
-	//check if vector is empty - and return the opposite answer: true if possible moves exist, meaning vector is non-empty
-	return !possibleMoves_.empty();
-}
-
-
-void Player::updatePossibleMoves(const std::vector<Location>& locs) {
-	//use copy constructor to copy the given vector to data member
-	//vector copies its internal elements as well - allows
-	possibleMoves_ = locs;
-}
-
-
-// if current Player "ate" the opposite Player - the opposite Player's score decreases
-void Player::decreaseScore (int toDecrease) {
-	score_ = score_ - toDecrease;
-}
-
-// if current Player "ate" the opposite Player - the opposite Player's score increases
-void Player::increaseScore (int toIncrease) {
-	score_ = score_ + toIncrease;
-}
diff --git a/run/Player.h b/run/Player.h
deleted file mode 100644
index dd8ea64..0000000
--- a/run/Player.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#ifndef PLAYER_H_
-#define PLAYER_H_
-
-#include <string>
-#include <vector>
-#include "Board.h"
-#include "Location.h"
-#include "ViewGame.h"
-
-class MoveLogic;
-
-/**
- * Repesenting a player in a Reversi game.
- * A player has a name and a color which represents him in the game.
- *
- * Abstract class, as there can be different types of players, which get their next moves in different ways.
- */
-class Player {
-public:
-	typedef Board::ElementInBoard ColorOfPlayer;
-
-	/**
-	 * Constructor of Player. Name and color must be given.
-	 *
-	 * @param name player's name
-	 * @param c player's color
-	 */
-	Player(const std::string& name, const ColorOfPlayer& c);
-
-	/**
-	 * Copy c'tor
-	 * @param player to copy
-	 */
-	Player(const Player& other);
-
-	/**
-	 * Virtual destructor.
-	 */
-	virtual ~Player();
-
-	/**
-	 * implement clone function for making copy of Player object
-	 * of any type. use clone because Player have derived classes.
-	 */
-	virtual Player* clone() const = 0;
-
-	/**
-	 * Returns player's next move in game. Is not constant, since getting next
-	 * move can cause player's members to change.
-	 *
-	 * Pure virtual method that must be implemented in derived classes,
-	 * since getting the next move depends on the player's type.
-	 *
-	 * @param v view to interact with player - accept input and make sure input is valid
-	 * @param logic rules of current game
-	 * @param b board on which game is being played
-	 * @param other opponent
-	 * @return location of next player's move
-	 */
-	virtual Location getNextMove(const ViewGame* view, const MoveLogic* logic, const Board& board, const Player* other) = 0;
-
-	/**
-	 * Returns the color representing this player in the game.
-	 * @return player color in the game
-	 */
-	ColorOfPlayer getColor() const;
-
-	/**
-	 * Returns the player's name in the game.
-	 *
-	 * @return player's name in the game
-	 */
-	const std::string& getName() const;
-
-	/**
-	 * Returns score of player.
-	 * @return current player's score
-	 */
-	int getScore() const;
-
-	/**
-	 * Return's the player's current possible moves, for examination only.
-	 * By reference, to avoid copying, constant - to avoid change.
-	 *
-	 * @return locations where the player could place a square with his color
-	 */
-	const std::vector<Location>& getPossibleMoves() const;
-
-	/**
-	 * Checks if player has possible moves to make.
-	 *
-	 * @return locations where the player could place a square with his color
-	 */
-	bool hasPossibleMoves() const;
-
-	/**
-	 * Updates the current locations where the player can make his next move to a new vector of possible moves.
-	 * Keeping the vector constant ensures that it will be copied.
-	 *
-	 * @param locs vector of new possible moves
-	 */
-	void updatePossibleMoves(const std::vector<Location>& locs);
-
-	/**
-	 * Decrease player's score by given amount.
-	 * @param toDecrease number of points to decrease.
-	 */
-	void decreaseScore (int toDecrease);
-
-	/**
-	 * Increase player's score by given amount.
-	 * @param toIncrease number of points to increase.
-	 */
-	void increaseScore (int toIncrease);
-
-protected:
-	// name of player, cannot be changed during game
-	const std::string name_;
-	// color of player in the game, cannot be changed during game
-	const Player::ColorOfPlayer color_;
-	//current score of player (number of cells with player's color
-	int score_;
-	//vector of currently possible moves to be made by the player
-	std::vector<Location> possibleMoves_;
-};
-
-
-#endif /* PLAYER_H_ */
diff --git a/run/Player.o b/run/Player.o
deleted file mode 100644
index 2e08e77..0000000
Binary files a/run/Player.o and /dev/null differ
diff --git a/run/StandardMoveLogic.cpp b/run/StandardMoveLogic.cpp
deleted file mode 100644
index ce5ba73..0000000
--- a/run/StandardMoveLogic.cpp
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * StandardMoveLogic.cpp
- */
-
-#include  "../include/StandardMoveLogic.h"
-#include <cstdlib> //for abs
-#include <vector>
-
-
-void StandardMoveLogic::playMove(const Location& move, Player* player, Board& board, Player* opponent) const {
-	//if move is illegal - do nothing
-	if (!isMoveAllowed(move, player)) {
-		return;
-	}
-
-	//initialize an array of 8 locations with the given move
-	Location dirs[8] = {move, move, move, move, move, move, move, move};
-
-	//get location of last square to flip in move in all directions
-	possibleMoveDirections(dirs, player->getColor(), board);
-
-
-	//in case move is at edge of board
-	if (board.isEdge(move)) {
-		//making sure a direction does not appear twice - to avoid flipping twice at edge case
-		//when move=edge, there are two overlapping directions (corner and edge withrow/column of move), so flipping is done twice
-		for (int i=0; i<8; i++) {
-			for (int j=i+1; j<8; j++) {
-				//if the location of a last square in one direction is equal to that of another (as in edge case - overlapping directions)
-				if (dirs[i]==dirs[j]) {
-					//change earlier direction to out of board (to allow further comparison) to out of range location
-					dirs[i] = move;
-				}
-			}
-		}
-	}
-
-
-	//go over directions and change colors in board + update players' scores
-	for (int i = 0; i<8; i++) {
-		//get jumps from move to end of range
-		int rowJumps = jumps(move.row(), dirs[i].row());
-		int colJumps = jumps(move.column(), dirs[i].column());
-
-		//change color
-		board.flipColorInRange(move, dirs[i], rowJumps, colJumps);
-
-		//update scores
-		//if the change has been in rows - use rows to update the scores
-		if (rowJumps != 0) {
-			//calculate difference (absolute value of move's row minus end of range's row)
-			int diff = abs(move.row()-dirs[i].row());
-			//increase difference from opponent and add to playing player
-			player->increaseScore(diff);
-			opponent->decreaseScore(diff);
-
-		//otherwise, if the change has been in columns - use columns to update the scores
-		} else if (colJumps != 0) {
-			//calculate difference (absolute value of move's row minus end of range's row)
-			int diff = abs(move.column()-dirs[i].column());
-			//increase difference from opponent and add to playing player
-			player->increaseScore(diff);
-			opponent->decreaseScore(diff);
-		}
-		//otherwise - there has been no change in the scores in this direction - do nothing
-	}
-
-	//make original move
-	board.makeInColor(player->getColor(), move);
-	//add 1 to player's score
-	player->increaseScore(1);
-}
-
-
-bool StandardMoveLogic::isPossibleMoveByLogic(const Player::ColorOfPlayer color, const Location& location, const Board& board) const {
-	//initialize an array of 8 locations with the given move
-	Location dirs[8] = {location, location, location, location, location, location, location, location};
-
-	//get location of last square to flip in move in all directions
-	possibleMoveDirections(dirs, color, board);
-
-	//check that at least one direction is different than original move
-	for (int i = 0; i<8; i++) {
-		if (dirs[i] != location) {
-			return true;
-		}
-	}
-	//otherwise - no directions to move to
-	return false;
-}
-
-
-void StandardMoveLogic::possibleMoveDirections(Location* dirs, const Player::ColorOfPlayer pColor, const Board& board) const {
-	/* IDEA:
-	 * Checks all directions of possible consecutive opposite colored sequence of squares relative to the given location,
-	 * and saves location of last square in opposite-colored range.
-	 * A direction which is an option for a move must have:
-	 * 1. at least one neighboring square with the opposite color
-	 * 2. the consecutive sequence of opposite colored neighboring squares ends with a same-colored square. */
-
-	//get size of board indexed to c++ indexing
-	int size = board.size()-1;
-
-	//initialize an array of 8 locations with the wanted directions of ranges - diagonally  ("towards board corners" - method
-	//knows to do that even when the move is not located in the center) and straight (to board edges)
-	Location ranges[8] = {Location(0,0), Location(0, dirs[0].column()), Location (0, size), Location (dirs[0].row(), size),
-			Location (size, size), Location (size, dirs[0].column()), Location (size, 0), Location (dirs[0].row(), 0)};
-
-	//save move
-	Location move = dirs[0];
-
-	//for each direction range in ranges
-	for (int i = 0; i<8; i++) {
-		//if move is not this edge of board - get last color in that direction
-		if (move != ranges[i]) {
-			//get last square in range with the opposite color than move's
-			Location loc(lastInColorRange(pColor, move, ranges[i], board));
-			dirs[i] = lastInColorRange(pColor, move, ranges[i], board);
-		}
-	}
-}
diff --git a/run/StandardMoveLogic.h b/run/StandardMoveLogic.h
deleted file mode 100644
index abf23c9..0000000
--- a/run/StandardMoveLogic.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- * StandardMoveLogic.h
- */
-
-#ifndef STANDARDMOVELOGIC_H_
-#define STANDARDMOVELOGIC_H_
-
-#include "MoveLogic.h"
-
-/**
- * Represent the standard move logic of a Reversi game.
- * A move is allowed only if it changes square colors, and square colors are changed if the new
- * move blocks a range of squares with the opposite color between move and a same-colored square.
- */
-class StandardMoveLogic: public MoveLogic {
-	public:
-		/**
-		 * Plays the given move for the given player on given board, according to the logic decided.
-		 * Changes must be made to board, so it cannot be constant.
-		 * Derived from parent class, originally a pure virtual method.
-		 *
-		 * Plays a move by switching the color of all consequent same-colored squares from given move.
-		 *
-		 * @param move location of chosen move
-		 * @param player pointer to player playing move
-		 * @param board pointer to board on which move is played
-		 * @param opponent pointer to other player of game
-		 */
-		virtual void playMove(const Location& move, Player* player, Board& board, Player* opponent) const;
-
-	protected:
-		/**
-		 * Checks if a given location can be a possible move by this logic's rules.
-		 * Is pure virtual because depends on the specific implementation of MoveLogic.
-		 *
-		 * @param color to make given cell location
-		 * @param location of cell
-		 * @param board pointer to board on which move is to be played
-		 */
-		virtual bool isPossibleMoveByLogic(const Player::ColorOfPlayer color, const Location& location, const Board& board) const;
-
-		/**
-		 * Checks if given move is an option for given player to make on the given board,
-		 * and if so - saves location of last square in opposite-colored range to the passed Locations array.
-		 *
-		 * In the standard rules, a direction can be possible for a move if it has at least one neightboring
-		 * square with opposite color, and if opposite colored square range is flanked by a square with same
-		 * color as move's.
-		 *
-		 * @param dirs array of 8 locations, initialized to checked move option location
-		 * @param pColor color of to player making the move
-		 * @param board pointer to board on which move is to be played
-		 */
-		virtual void possibleMoveDirections(Location* dirs, const Player::ColorOfPlayer pColor, const Board& board) const;
-};
-
-
-
-#endif /* STANDARDMOVELOGIC_H_ */
diff --git a/run/StandardMoveLogic.o b/run/StandardMoveLogic.o
deleted file mode 100644
index 5c6ccbe..0000000
Binary files a/run/StandardMoveLogic.o and /dev/null differ
diff --git a/run/ViewByConsole.cpp b/run/ViewByConsole.cpp
deleted file mode 100644
index 480e98b..0000000
--- a/run/ViewByConsole.cpp
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#include "../include/ViewByConsole.h"
-#include <iostream>
-#include <string>
-using namespace std;
-
-void ViewByConsole::printBoard(Board::ElementInBoard** board, int sizeOfBoard) const
-{
-	//print the indexes of the columns
-	cout << " | ";
-	for(int i=1; i<=sizeOfBoard ;++i)
-	{
-		cout << i << " | ";
-	}
-	cout << endl;
-	// print spaces line
-	cout << "----------------------------------" << endl;
-	// print the content of the board
-	for(int i=0; i<sizeOfBoard ;++i)
-	{
-		// the index of the line
-		cout << i+1 << "|";
-		for(int j=0; j<sizeOfBoard; ++j)
-		{
-			switch(board[i][j])
-			{
-			case Board::BLACK:
-				cout << " X |";
-				break;
-			case Board::WHITE:
-				cout << " O |";
-				break;
-			case Board::EMPTY:
-				cout << "   |";
-				break;
-			default:
-				break;
-			}
-
-		}
-		cout << endl;
-		// print spaces line
-		cout << "----------------------------------" << endl;
-	}
-}
-
-void ViewByConsole::messageForTurn(string curPlayer) const
-{
-	cout<<curPlayer<<": It's your move"<< endl;
-}
-
-void ViewByConsole::messagePossibleMoves(const vector<Location> &possibleMoves) const
-{
-	int possibleMovesSize = possibleMoves.size();
-	cout<<"Your possible moves: ";
-	for (int i=0; i<possibleMovesSize; ++i)
-	{
-		cout << possibleMoves[i];
-		if( i == possibleMovesSize-1)
-		{
-			cout << endl;
-		}
-		else
-		{
-			cout << ",";
-		}
-	}
-}
-
-Location ViewByConsole::getMoveFromUser() const
-{
-	int row;
-	int col;
-
-	//get player's move
-	cin >> row;
-	cin >> col;
-
-	// input validation: while the input is not valid - keep asking for valid one
-	while(cin.fail())
-	{
-		showMessage("Invalid move format, please try again! Enter your move row,col: ");
-		cin.clear();
-		cin.ignore();
-		cin >> row;
-		cin >> col;
-	}
-
-	return Location(row-1,col-1);
-}
-
-
-void ViewByConsole::messageWinner(string winPlayer) const
-{
-	cout << winPlayer << " has won the game!" << endl;
-}
-
-
-void ViewByConsole::showMessage(string stringToShow) const
-{
-	cout<<stringToShow<<endl;
-}
-
-
-void ViewByConsole::messagePlayerMove(Location pointToDisplay, string curPlayer)const
-{
-	cout<<curPlayer<<" played "<< pointToDisplay << endl;
-}
-
-
-void ViewByConsole::messageSwitchTurns() const
-{
-	showMessage("No possible moves. Play passes to the other player. Press any key to continue.");
-	char anyKey;
-	cin >> anyKey;
-}
-
-
-int ViewByConsole::presentMenu(const vector<string>& menuOpps) const
-{
-	//show menu title
-	showMessage(menuOpps[0]);
-
-	//go over options vector to show options
-	for (int i=1; i < menuOpps.size(); i++)
-	{
-		//show option and index
-		cout << "To " << menuOpps[i] << ", press " << (i) << endl;
-	}
-
-	//get player's choice
-	int choice;
-	cin >> choice;
-
-	// input validation: while the input is not valid- keep asking for valid one
-	//input is not valid if it is either not a number, or is not in range of given options [1-size]
-	while(cin.fail() || choice<1 || choice > menuOpps.size())
-	{
-
-		showMessage("Choice must be a number from given options, please try again:");
-		cin.clear();
-		cin.ignore();
-		cin >> choice;
-	}
-
-	//translate choice back to c++ indexing and return it
-	return choice;
-}
diff --git a/run/ViewByConsole.h b/run/ViewByConsole.h
deleted file mode 100644
index c62e8a2..0000000
--- a/run/ViewByConsole.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * ViewByConsole.h
- *
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#ifndef VIEWBYCONSOLE_H_
-#define VIEWBYCONSOLE_H_
-#include "ViewGame.h"
-
-class ViewByConsole : public ViewGame
-{
-public:
-
-	ViewByConsole() {}
-	~ViewByConsole() {}
-	// present the board
-	virtual void printBoard(Board::ElementInBoard** board, int sizeOfBoard) const;
-
-	// message to switch turns
-	virtual void messageForTurn (string curPlayer) const;
-
-	// message of possible moves
-	virtual void messagePossibleMoves(const vector<Location> &possibleMoves) const;
-
-	// display the player's last move
-	virtual void messagePlayerMove(Location pointToDisplay, string curPlayer) const;
-
-	// message who is the winner
-	virtual void messageWinner(string winPlayer) const;
-
-	//show any type of message
-	virtual void showMessage(string stringToShow) const;
-
-	//shows switcing turns message and waits for any key press
-	virtual void messageSwitchTurns() const;
-
-	//gets move from outside user of game
-	virtual Location getMoveFromUser() const;
-
-	/**
-	 * Shows the options in the vector by option's index, and returns user's choice.
-	 *
-	 * Index 0 should be menu's title, and other indexes should hold the matching message for the option.
-	 * Messages should fit the format: "To MESSAGE, press INDEX"
-	 */
-	virtual int presentMenu(const vector<string>& menuOpps) const;
-};
-#endif /* VIEWBYCONSOLE_H_ */
diff --git a/run/ViewByConsole.o b/run/ViewByConsole.o
deleted file mode 100644
index f9ac37a..0000000
Binary files a/run/ViewByConsole.o and /dev/null differ
diff --git a/run/ViewGame.h b/run/ViewGame.h
deleted file mode 100644
index 09db305..0000000
--- a/run/ViewGame.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Yael Hacmon, ID 313597897
- * Roni Fultheim, ID 313465965
- */
-
-#ifndef VIEWGAME_H_
-#define VIEWGAME_H_
-#include "Board.h"
-#include <vector>
-
-using namespace std;
-
-/**
- * Represents the view of the game, handles any interaction with the player.
- * All functions are pure virtual, seeing as implementation depends on viewing tools (console, GUI, etc.)
- */
-class ViewGame {
-	public:
-		//virtual c'tor and d'tor (must have - includes virtual methods)
-		ViewGame() {}
-		virtual ~ViewGame() {}
-
-		// present the board
-		virtual void printBoard(Board::ElementInBoard** board, int sizeOfBoard) const = 0;
-
-		// message to switch turns
-		virtual void messageForTurn (string curPlayer) const = 0;
-
-		// message of possible moves
-		virtual void messagePossibleMoves(const vector<Location> &possibleMoves) const = 0;
-
-		// display the player's last move
-		virtual void messagePlayerMove(Location pointToDisplay, string curPlayer) const = 0;
-
-		// message who is the winner
-		virtual void messageWinner(string winPlayer) const = 0;
-
-		//show any type of message
-		virtual void showMessage(string stringToShow) const = 0;
-
-		//shows switching turns message and waits for any key press
-		virtual void messageSwitchTurns() const = 0;
-
-		//gets move from outside user of game
-		virtual Location getMoveFromUser() const = 0;
-
-		/**
-		 * Shows the options in the vector by option's index, and returns user's choice.
-		 *
-		 * Index 0 should be menu's title, and other indexes should hold the matching message for the option.
-		 * Messages should fit the format: "To MESSAGE, press INDEX"
-		 */
-		virtual int presentMenu(const vector<string>& menuOpps) const = 0;
-};
-
-#endif /* VIEWGAME_H_ */
diff --git a/run/a.out b/run/a.out
deleted file mode 100755
index c844f5b..0000000
Binary files a/run/a.out and /dev/null differ
diff --git a/run/main.cpp b/run/main.cpp
deleted file mode 100644
index 85fbad7..0000000
--- a/run/main.cpp
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Roni Fultheim, ID: 313465965
- *
- * main.cpp
- * Implementation of main function - runs program
- */
-
-#include <iostream>
-#include "../include/GameManager.h"
-#include "../include/Player.h"
-#include "../include/Board.h"
-#include "../include/Menu.h"
-#include "../include/ViewByConsole.h"
-#include "../include/HumanPlayer.h"
-#include "../include/StandardMoveLogic.h"
-#include <string>
-
-using namespace std;
-
-
-int main() {
-
-	//allocate menu, board, logic and view on stack - currently there is only one type of logic and view, no need to allocate dynamically
-	Menu menuReversi;
-	Board board;
-	StandardMoveLogic ml;
-	ViewByConsole view;
-
-	//allocate dynamically due to using abstract base type
-	//first player is always the human player and is black
-	Player* player1 = new HumanPlayer("X",Board::BLACK);
-
-	//start game - opening message
-	view.showMessage("Welcome to Reversi!");
-
-	//getting white player by user's choice from player options menu
-	Player* player2 = menuReversi.getPlayerByUserChoice(view);
-
-	//allocate game manager on stack, sending abstract types by pointer and actual types by reference
-	GameManager game_manger(&view, board, player1, player2, &ml);
-
-	// play game
-	game_manger.playGame();
-
-	//release memory
-	delete player1;
-	delete player2; //was allocated in menu, but must be released here
-
-	return 0;
-}
diff --git a/run/main.o b/run/main.o
deleted file mode 100644
index 38f7804..0000000
Binary files a/run/main.o and /dev/null differ
diff --git a/run/makefile b/run/makefile
deleted file mode 100644
index 07d6057..0000000
--- a/run/makefile
+++ /dev/null
@@ -1,37 +0,0 @@
-a.out: Board.o Player.o HumanPlayer.o ComputerPlayer.o Location.o MoveLogic.o StandardMoveLogic.o ViewByConsole.o Menu.o GameManager.o main.o
-	g++ Board.o Player.o HumanPlayer.o ComputerPlayer.o Location.o MoveLogic.o StandardMoveLogic.o ViewByConsole.o Menu.o GameManager.o main.o
-
-#creating all object files from source code
-
-Board.o: Board.cpp Board.h Location.h
-	g++ -c Board.cpp
-
-Player.o: Player.cpp Player.h Location.h
-	g++ -c Player.cpp
-
-HumanPlayer.o: HumanPlayer.cpp HumanPlayer.h Player.h
-	g++ -c HumanPlayer.cpp
-	
-ComputerPlayer.o: ComputerPlayer.cpp ComputerPlayer.h Player.h
-	g++ -c ComputerPlayer.cpp
-	
-Location.o: Location.cpp Location.h
-	g++ -c Location.cpp
-
-MoveLogic.o: MoveLogic.cpp MoveLogic.h Player.h Location.h
-	g++ -c MoveLogic.cpp
-
-StandardMoveLogic.o: StandardMoveLogic.cpp StandardMoveLogic.h MoveLogic.h
-	g++ -c StandardMoveLogic.cpp
-
-ViewByConsole.o: ViewByConsole.cpp ViewByConsole.h ViewGame.h
-	g++ -c ViewByConsole.cpp
-	
-Menu.o: Menu.cpp Menu.h Player.h ViewGame.h
-	g++ -c Menu.cpp
-	
-GameManager.o: GameManager.cpp GameManager.h Board.h MoveLogic.h Player.h
-	g++ -c GameManager.cpp
-	
-main.o: main.cpp GameManager.h HumanPlayer.h StandardMoveLogic.h Board.h Player.h ViewByConsole.h Menu.h
-	g++ -c main.cpp
